# Copyright (c) 2022 Roelof Bart Toonen
# License: MIT license (spdx.org MIT)
# NldsPredExamples.R

require (NldsPred)
require (dplyr)

# compLV
# Simulate competitive Lotka Volterra system
# r1, a11 and a12 are the parameters for species 1.
# r2, r21 and a22 are the parameters for species 2.
# sd1m and sd2m are the standard deviations of model noise for species 1 and 2.
# sd1o and sd2o are the standard deviations of observational noise for 
# species 1 and 2.

compLV <- function (x1, r1, a11, a12, y1, r2, a21, a22, sd1m, sd1o, sd2m,
                    sd2o, n)
{
    set.seed (10)
    # Create time series for 2 variable model + stochastic influence.
    makeNoise <- function (s, n)
    {
        if (s == 0.0)
            return (rep (0.0, n))
        else
            return (rnorm (n, mean = 0.0, sd = s))
    }

    xmnoise = makeNoise (sd1m, n)
    ymnoise = makeNoise (sd2m, n)
    xonoise = makeNoise (sd1o, n)
    yonoise = makeNoise (sd2o, n)

    x  = rep(NA, n)
    y  = rep(NA, n)
    ti = 1:n

    x[1] = x1 + xmnoise[1]
    y[1] = y1 + ymnoise[1]

    for(t in 2:n)
    {
        x[t] = x[t-1]*(1 + r1 - a11*x[t-1] - a12*y[t-1]) + xmnoise[t]
        y[t] = y[t-1]*(1 + r2 - a21*y[t-1] - a22*x[t-1]) + ymnoise[t]
    }

    x = x + xonoise
    y = y + yonoise

    ts = data.frame(ti, x, y)

    return (ts)
}

# Create a dataset to work with
data1 = compLV (x1 = 0.2, r1 = 2.7, a11 = 3.7, a12 = 0.05,
                y1 = 0.4, r2 = 2.7, a21 = 3.7, a22 = 0.38,
                sd1m = 0.0, sd1o = 0.0, sd2m = 0.0, sd2o = 0.0, 210)
data1 = data1[10:NROW(data1),]

###############################################################################
# Example 1:
# Predict y from x, using a weighted mean of the y values of the neighbors in 
# the embedding for variable x.

# Create a list with parameters for the exponential prediction function.
fo <- NldsPredFnExpOpts (expK = 1.0, nnnAdd = 1, excl = "timeCoord",
                         fnDenom = "avgNn", objectOnlyOnce = FALSE)

# Create a list with validation set options for bootstrapping.
so <- NldsPredSetBootstrap (nBootstrap = 50, libSizeIsEmbSize = TRUE)

# Create normalized matrix for the time-series columns.
ds <- scale (data.matrix (data.frame(x = data1$x, y = data1$y),
                          rownames.force = NA),
             center = TRUE,
             scale = TRUE)

# Run while using the following embeddings, all predicting the current 
# value of x (x0):
# 1-dimensional embedding containing current values of y (y0).
# 2-dimensional embedding containing the current and previous
#   value of y (y0, y1).
# 3-dimensional embedding containing (y0, y1, y2).
# 4-dimensional embedding containing (y0, y1, y2, y3).
fname <- NldsPredRun (data = ds, logFile = tempfile(), fnOpts = fo,
                      setOpts = so, time = data1$ti,
                      embRangeDef = "y,0,3,1,trail:x,0")

# Extract coordinates of points used in each embedding.
embpoints <- NldsPredGetTable (logFileName = fname,
                 fieldNames = c("embpar1_emb_label", "embpar1_emb_num",
                                "embpar1_n_row", "embpar1_e",
                                "embpar1_n_pre_val", "embpar1_n_bundle_val",
                                "vid_vec_num", "val_copr", "val_idx", "val_t",
                                "val_val"),
                 newRecName = "VAL")

# Extract id's of vectors in each bootstrap set
bootstrap_vecs <- NldsPredGetTable (logFileName = fname,
                    fieldNames = c("embpar1_emb_num", "spbt_boot_i",
                                   "sh_set_code", "sh_set_num", "sh_n_point",
                                   "sd_set_code", "sd_vec_idx", "sd_vec_num"),
                    newRecName = "SD")

# Extract the nearest neighbors, for each predictee vector,
# in eacht bootstrap set.
nn <- NldsPredGetTable (logFileName = fname,
        fieldNames = c("embpar1_emb_num", "spbt_boot_i",
                       "tg1_target_num", "nn_seq", "nn_num", "nn_sqdst"),
        newRecName = "NN")

# Extract the predicted values, for each predictee vector,
# in eacht bootstrap set.
pv <- NldsPredGetTable (logFileName = fname,
        fieldNames = c("embpar1_emb_num", "spbt_boot_i",
                       "tg2_target_num", "pd_pre_val_num",
                       "pd_pre_val", "pd_obs_val"),
        newRecName = "PD")

# Extract general statistics that were generated by NldsPredRun.
stats <- NldsPredGetTable(logFileName = fname,
             fieldNames = c("embpar1_emb_num", "embpar1_e", "spbt_boot_i",
                            "stat_n_pre_obs", "stat_avg_obs", "stat_var_pre",
                            "stat_var_obs", "stat_cov_pre_obs",
                            "stat_mae_pre_obs", "stat_rmse_pre_obs",
                            "stat_md_pre", "stat_md_obs", "stat_mdad_pre",
                            "stat_mdad_obs", "stat_mdae_pre_obs"),
             newRecName = "STAT")

# Show the embedding labels, the corresponding embedding number, the dimension
# and the number of vectors in the embedding.
print(select(embpoints, embpar1_emb_label, embpar1_emb_num, embpar1_e,
                        embpar1_n_row) %>% distinct())

# Show the vector numbers, the coordinate and predictee values, and their
# corresponding time indices for the first 5 vectors of the embedding with
# mbpar1_emb_num = 1.
# Note: C = coordinate value, P = observed value for the value that will
#       be predicted. val_t = 0 is the first value of the time series
print(filter(embpoints, embpar1_emb_num == 1, vid_vec_num < 5) %>%
      select(vid_vec_num, val_copr, val_idx, val_t, val_val))

# Show the contents of the first bootstrap set for the embedding with 
# embpar1_emb_num = 1. Show the first 5 points from the library set and from
# the predictee set.
# Note: set_code 'L' is library vector, 'P' is predictee vector,
#       set_num = bootstrap set number,
#       vec_idx = index nummer within this bootstrap set,
#       vec_num = the vector number from the embedding.
print(filter(bootstrap_vecs, embpar1_emb_num == 1, sh_set_num == 0,
             sd_vec_idx < 5) %>%
      select(sh_set_code, sh_set_num, sd_vec_idx, sd_vec_num))

# Show the nearest neighbors for each vector from the first bootstrap set of
# the embedding with embpar1_emb_num = 1.
# Show this for the first 5 vectors.
# Also show the squared distance to those nearest neighbors.
#    tg1_target_num = vector number from the predictee set,
#    nn_seq         = nearest neighbor counter,
#    nn_num         = vector number of neighbor (corresponds to vid_vec_num),
#    nn_sqdst       = squared distance between target vector and the neighbor,
print(filter(nn, embpar1_emb_num == 1, spbt_boot_i == 0,
             tg1_target_num < 5) %>%
      select(tg1_target_num, nn_seq, nn_num, nn_sqdst))

# To check the nearest neighbor algorithm, compute the squared distances to
# all other vectors in the bootstrap set, for each vector from the predictee
# set (the set with all target vectors).
pred_vec <- filter(bootstrap_vecs, embpar1_emb_num == 1, sh_set_num == 0,
                   sh_set_code == "P") %>%
            select(sd_vec_num) %>%
            rename(pred_vec_num = sd_vec_num)

lib_vec <- filter(bootstrap_vecs, embpar1_emb_num == 1, sh_set_num == 0,
                  sh_set_code == "L") %>%
           select(sd_vec_num) %>%
           arrange(sd_vec_num) %>%
           rename(lib_vec_num = sd_vec_num)

# Because of bootstrapping, some vectors appear multiple times.
# Summarise these into aggregated rows.
lib_vec <- group_by(lib_vec, lib_vec_num) %>%
           summarise(n = n())

combined <- cross_join(pred_vec, lib_vec)

# Add the vector scalar values for the prediction vectors.
#   val_idx = coordinate number,
#   val_val = coordinate value.
embpoints <- filter(embpoints, embpar1_emb_num == 1, val_copr == "C") %>%
              select(vid_vec_num, val_idx, val_val)

combined <- left_join(combined, embpoints, multiple = "all",
                      by = c("pred_vec_num" = "vid_vec_num")) %>%
            rename (pred_vec_val = val_val)

# Add the vector scalar values for the library vectors
combined <- left_join(combined, embpoints,
                      by = c("lib_vec_num" = "vid_vec_num",
                             "val_idx" = "val_idx") ) %>%
            rename (lib_vec_val = val_val)

# Compute the squared distances
combined <- mutate(combined, sqdiff = (lib_vec_val - pred_vec_val)^2) %>%
            group_by(pred_vec_num, lib_vec_num, n) %>%
            summarise(sqdist = sum(sqdiff))

print(filter(combined, pred_vec_num < 5, lib_vec_num < 10))

# For the first bootstrap set of embedding with emb_num = 1, show the predicted
# values versus the observed values.
print(filter(pv, embpar1_emb_num == 1, spbt_boot_i == 0,
             tg2_target_num < 5) %>%
      select(tg2_target_num, pd_pre_val, pd_obs_val))

# Compute the average predicted value over all bootstrap sets, for each
# predictee vector, and compare with the observed value.

avgpv <- ungroup(pv) %>%
         filter(embpar1_emb_num == 1) %>%
         select(tg2_target_num, pd_obs_val, pd_pre_val) %>%
         group_by(tg2_target_num) %>%
         summarise(avg_pre_val = mean(pd_pre_val),
                   obs_val = first(pd_obs_val))
print(filter(avgpv,tg2_target_num < 5))

# Calculate the mean square error.
mse <- ungroup(avgpv) %>%
    mutate(sqdiff = (avg_pre_val - obs_val)*(avg_pre_val - obs_val)) %>%
    summarise(mse = mean(sqdiff), sdobs = sd(obs_val), sdpre = sd(avg_pre_val))

cat("MSE:          ", sqrt(mse$mse), "\n")
cat("SD Observed:  ", mse$sdobs, "\n")
cat("SD Predicted: ", mse$sdpre, "\n")
cat("Correlation:  ", cor(avgpv$obs_val, avgpv$avg_pre_val), "\n")

plot(x = avgpv$obs_val, y = avgpv$avg_pre_val)
